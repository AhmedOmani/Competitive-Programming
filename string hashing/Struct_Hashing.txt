#include <bits/stdc++.h>
#define all(v) v.begin() , v.end()
#define Pi 3.14159
using namespace std;

using ll = long long;

ll gcd(ll a, ll b) { return ((b == 0) ? a : gcd(b, a % b)); }
ll lcm(ll a, ll b) { return (b / gcd(a, b)) * a; }


void Omani () {
ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);
#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
#endif
}

const int N = 2e5 + 5, P1 = 29, P2 = 31, MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;
int pw1[N], inv1[N], pw2[N], inv2[N];

int add(int a, int b, int mod)
{
    return (a + b) % mod;
}

int sub(int a, int b, int mod)
{
    return ((a - b) % mod + mod) % mod;
}

int mul(int a, int b, int mod)
{
    return 1ll * a * b % mod;
}

int fp(int base, int power, int mod)
{
    if(!power)
        return 1;

    int ret = fp(base, power >> 1, mod);
    ret = mul(ret, ret, mod);

    if(power & 1)
        ret = mul(ret, base, mod);

    return ret;
}

struct Hash
{
    vector<pair<int, int>> prefix;

    Hash(const string &s)
    {
        prefix.resize(s.size() + 1);
        for(int i = 0; i < int(s.size()); ++i)
            prefix[i + 1] = make_pair(add(prefix[i].first, mul(pw1[i], s[i] - 'a' + 1, MOD1), MOD1),
                                      add(prefix[i].second, mul(pw2[i], s[i] - 'a' + 1, MOD2), MOD2));
    }

    int size() const
    {
        return prefix.size() - 1;
    }

    pair<int, int> getHash() const
    {
        return prefix.back();
    }

    pair<int, int> getRange(int l, int r) const
    {
        return make_pair(mul(inv1[l], sub(prefix[r + 1].first, prefix[l].first, MOD1), MOD1),
                         mul(inv2[l], sub(prefix[r + 1].second, prefix[l].second, MOD2), MOD2));
    }

    static void prepare()
    {
        pw1[0] = inv1[0] = pw2[0] = inv2[0] = 1;
        int iv1 = fp(P1, MOD1 - 2, MOD1);
        int iv2 = fp(P2, MOD2 - 2, MOD2);
        for(int i = 1; i < N; ++i)
        {
            pw1[i] = mul(pw1[i - 1], P1, MOD1);
            inv1[i] = mul(inv1[i - 1], iv1, MOD1);
            pw2[i] = mul(pw2[i - 1], P2, MOD2);
            inv2[i] = mul(inv2[i - 1], iv2, MOD2);
        }
    }
};


void Solve() {

}

int main() {
Omani() ;
Hash::prepare();
int T = 1 ;                                    ///cin >> T ;
while(T--) Solve() ;
}
