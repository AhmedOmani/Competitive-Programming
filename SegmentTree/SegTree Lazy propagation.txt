struct Node{    ll mn = LLONG_MAX;}; struct segTree{    vector<ll> lazy;    vector<Node> tree;    Node neutral = Node();     segTree(int n)    {        int sz = 1;        while(sz < n)            sz *= 2;         lazy = vector<ll>(2 * sz);        tree = vector<Node>(2 * sz);    }     Node merge(Node u, Node v)    {        Node ret;        ret.mn = min(u.mn, v.mn);        return ret;    }     Node single(int val)    {        Node leaf;        leaf.mn = val;        return leaf;    }     void propagate(int node, int s, int e)    {        tree[node].mn += lazy[node];        if(s != e)        {            lazy[node * 2] += lazy[node];            lazy[node * 2 + 1] += lazy[node];        }        lazy[node] = 0;    }     void build(int node, int s, int e, vector<int> &v)    {        if(s == e)        {            tree[node] = single(v[s]);            return;        }         int mid = (s + e) >> 1;         build(node * 2, s, mid, v);        build(node * 2 + 1, mid + 1, e, v);         tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);    }     void update(int node, int s, int e, int l, int r, int val)    {        propagate(node, s, e);         if(s > r || e < l)            return;         if(s >= l && e <= r)        {            tree[node].mn += val;            if(s != e)            {                lazy[node * 2] += val;                lazy[node * 2 + 1] += val;            }            return;        }         int mid = (s + e) >> 1;         update(node * 2, s, mid, l, r, val);        update(node * 2 + 1, mid + 1, e, l, r, val);         tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);    }     Node query(int node, int s, int e, int l, int r)    {        if(s > r || e < l)            return neutral;         propagate(node, s, e);         if(s >= l && e <= r)            return tree[node];         int m = (s + e) >> 1;         Node u = query(node * 2, s, m, l, r);        Node v = query(node * 2 + 1, m + 1, e, l, r);         return merge(u, v);    }}; 